# 卡普拉斯-斯特朗算法（Karplus-Strong Algorithm）

卡普拉斯-斯特朗算法（Karplus-Strong Algorithm, K-S Algorithm）是一种物理建模合成方法，它通过对一个短的起始波形循环地进行“滤波-延迟”来模拟击弦或拨弦乐器，以及某些类型的打击乐器的声音。这种技术可以看作是在一个有梳状滤波器的反馈回路进行减法合成；如果将存储信号的延迟块视作波表的话，也可以被看作是最简单的一类波表变换算法，即“数字波导合成”。

Alexander Strong发明了该算法，而Kevin Karplus首先分析了它的工作原理。他们一起开发了算法的软件和硬件实现，包括定制的VLSI芯片。他们将算法命名为“Digitar”合成，意为“数字的（Digital）”与“吉他（Guitar）”。

## 产生声音

概括而言，卡普拉斯-斯特朗算法由“激励-延迟-滤波-循环”四步组成，具体过程如下：

![KS Algorithm](/resources/images/Karplus-strong-schematic.svg)

> from [Karplus-Strong Algorithm - Wikipedia](https://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis)

1. 生成一个L样本长度的短激励信号。在最初的算法中，这是一个白噪声脉冲，但可以使用任何具有丰富谐波的信号（例如快速的正弦波啁啾或扫频，或者单周期的锯齿波或方波）作为激励信号，这一信号决定了最终的音色。
2. 直接输出激励信号，同时逐样本地放入同样长度为L个样本的暂存块（队列形式，先入先出）中。
3. 暂存块中的信号通过一个滤波器，该滤波器的增益在所有频率下都必须小于 1，以保持反馈环路的稳定。在原始算法中，“滤波”是通过对两个相邻样本求平均实现的，这种实现很简单，仅需要移位和加法运算，无需乘法。滤波器的特性决定了衰减后音调的谐波结构，一般实现中使用低通滤波器，这样声音的高频分量更快地损失，与弦振动的衰减情况相似。
4. 滤波后的结果送往输出，同时也用以覆盖暂存块中的信号，接下来将这个新信号再次通过滤波器，如此循环。

## 改变音调

所得信号的基频（最低非零泛音）是延迟和滤波器的组合在相位响应为 $−2π$ 的最低频率，也就是说，暂存块和滤波器组成的系统中总延迟时间的确定了所得到信号的基频。基频 $F_0$ 所对应的相位延迟D可以由 $D = F_s/F_0$ 确定，其中 $F_s$ 是采样频率。

虽然数字延迟器的大小是采样周期的整数倍，但可以通过插值滤波器提供延迟，从而获得非整数倍延迟，进而微调频率。IIR和FIR滤波器都可以作为此用，但 FIR 滤波器的优势在于，所需延迟随时间变化时可以抑制瞬变。

最基本的非整数倍延迟实现方法是两个样本之间的线性插值（例如， $s (4.2) = 0.8 s (4) + 0.2 s (5)$ ）。如果相位延迟随频率变化，谐波相对于基频可能会变尖或变平。原始算法对两个相邻样本使用相等的权重，因为这可以在没有乘法硬件的情况下实现，从而允许极其廉价的实现。

1983 年介绍该算法的论文中说明，Z 变换分析可用于更精确地获取谐波的音调和衰减时间。

保持缓冲周期（即暂存块的长度）恒定会产生类似于弦或铃的振动，而在短暂的激励信号后急剧增加缓冲周期则会产生类似鼓的声音。

## 算法的改进

因为在一些情况下合成的音色类似于拨弦，Alex Strong 和 Kevin Karplus 认为K-S算法某种意义上属于弦振动的物理建模，他们试着证明这一算法表示了弦的振动方程，但证明没有完成。 Julius O. Smith III 认识到，当将 K-S 算法视为数字滤波器时，其传递函数与振动弦的传递函数一致，滤波器对应于弦振动过程中的能量损失。 后来他将 K-S 算法推广为数字波导合成（用于模拟弦、管和膜中的声波的算法）中的一个特例。

K-S 算法的第一次扩展和推广被称为扩展 Karplus-Strong (EKS) 算法，最初于 1982 年在意大利威尼斯举行的国际计算机音乐会议上发表在一篇论文中，之后于 1983 年 David A. Jaffe 和 Julius O. Smith 在计算机音乐杂志 (Computer Music Journal) 上发表的题为“Extensions of the Karplus Strong Plucked String Algorithm（卡普拉斯-斯特朗拨弦算法的扩展）”的文章，以及 Smith 的博士/电子工程师论文中做了更详细的解释。

Alex Strong开发了一种用于弹拨合成的高级波表修改方法，但仅作为专利发布。
